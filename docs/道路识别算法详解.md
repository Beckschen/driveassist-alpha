# 道路识别算法详解

本文详细描述了当前代码中（git 版本: 16b521b12d2e3bdc00bd996acafe4526f1d1cb9a）道路识别的算法。

如果没有特殊说明，下文中所说的“算法”均指本代码中的道路识别算法。

## 目标

本算法的目标是识别出道路上较为清晰的道路标线，并给出道路标线的位置信息。

## 算法简要流程

1. 选取 ROI（感兴趣区域）；
1. 对 ROI 进行俯视变换，得到鸟瞰图；
1. 对鸟瞰图进行增强处理，增强车道线；
1. 使用一个简化过的霍夫变换，识别直线，并作为可能的候选车道线；
1. 使用上一步中得到的候选车道线，结合图像信息，拟合出实际的车道线。

## 详细流程

为了结合代码进行说明，将使用代码导读的方式慢慢分析算法。由于代码仍在开发中，变动频繁，建议你检出 tag 为 lane-detection-code-tour 的代码进行对照阅读。


### 选取 ROI

main() 函数位于 driveassist.cpp 文件中，该文件的开始部分定义了一些用于测试的视频的参数。由于该版本的代码仅做研究用，所以将测试视频文件的地址写死在了代码中。

roiX、roiY、roiWidth、roiHeight 就是 ROI 的参数，由于车道线仅仅会出现在视频画面中的固定区域，所以我们可以选取这块固定的区域作为 ROI，这样可以加快处理的速度，也可以避开环境的干扰。

ROI 参数根据不同的视频需要自行调节。


### 进行俯视变换

从视频画面中来看，车道线是倾斜而且不平行的，但如果我们从空中俯视车道线，应该能看到平行的车道线。平行的车道线比不平行的车道线更容易处理。另外，当我们把 ROI 变换成 IPM 后，在直行的道路上，车道线会变成垂直的线，这就能够让我们更容易地识别出车道线。

要严格地进行俯视变换，需要考虑到摄像头高度、倾角、仰角、光圈大小等不容易测量的量，但我们不需要进行精确的变换，我们只需要做一个简单的梯形变形，就能够得到一个俯视图。虽然这样做得到的俯视图并不精确，但对车道线识别来说已经够用了。

由于摄像头安装位置的不同，我们需要根据实际画面调整一些参数，以便进行俯视变换，我们将这个过程叫做标定。下面介绍标定的过程。

首先运行程序，选择一个车辆保持在车道线中央，且当前车道是直道的场景，接着开始进行标定。

请看下图，图片底部中央的绿色细线的矩形就是 ROI，举行中央的两条绿色细线是用于调整俯视变换参数的辅助线。

![01-标定 ROI 和俯视变换参数](http://youxia-cdn.b0.upaiyun.com/user/da/ec/2fbdc130b09772288745f78ff68f.png)

标定方法如下：

1. 调整“原图”窗口中的参数，让 ROI 的左下角和右下角正好压在实际的车道线上，ROI 的下边线应该尽可能接近画面的底部；
1. 调整“感兴趣区域”窗口中的 srcX 参数，让 ROI 中两条绿色细线和 ROI 上边线的交点正好压在实际的车道线上；
1. 在确保满足前两条的条件下，适当调整 ROI 上边线的位置，尽量让 ROI 有较高的高度，同时确保 ROI 中两条绿色辅助线不要相距太近。

标定原理是这样的，画面中的车道线和 ROI 的上下两条边线组成了一个梯形，我们只要把这个梯形拉伸成一个矩形，就可以完成俯视变换。严格来说，这并不是一个标准的俯视变换，但我们只需要将车道线变换成平行的且垂直于地平线的两条线，这样的变换对我们来说已经足够了。

如下图所示，我们需要将 E、F 点分别拉伸到 A、B 两点，C 和 D 点保持不动，也就是说，我们的变换是这样的：

![02-俯视变换中的梯形变形](http://youxia-cdn.b0.upaiyun.com/user/c4/50/cc5865b692f64efcda2a2c2a0c7c.png)

* E --> A
* F --> B
* C --> C
* D --> D

将这四个点的坐标传给 OpenCV 提供的 getPerspectiveTransform 方法，我们就得到了我们想要的俯视变换的变换矩阵。同时，我们可以求这个矩阵的伪逆矩阵，这样我们就可以将俯视图转换为 ROI 图。


下面是一个 ROI 转换成俯视变换的对比图，可以看出车道线已经变成了两条平行线，并且在屏幕上是垂直的。

![03-ROI 和俯视变换的对比](http://youxia-cdn.b0.upaiyun.com/user/4e/7a/da2f9686aec9f6cc5bc2017f8700.png)


