# 道路识别算法详解

本文详细描述了当前代码中（git 版本: 16b521b12d2e3bdc00bd996acafe4526f1d1cb9a）道路识别的算法。

如果没有特殊说明，下文中所说的“算法”均指本代码中的道路识别算法。

## 目标

本算法的目标是识别出道路上较为清晰的道路标线，并给出道路标线的位置信息。

## 算法简要流程

1. 选取 ROI（感兴趣区域）；
1. 对 ROI 进行俯视变换，得到鸟瞰图；
1. 对鸟瞰图进行增强处理，增强车道线；
1. 使用一个简化过的霍夫变换，识别直线，并作为可能的候选车道线；
1. 使用上一步中得到的候选车道线，结合图像信息，拟合出实际的车道线。

## 详细流程

为了结合代码进行说明，将使用代码导读的方式慢慢分析算法。由于代码仍在开发中，变动频繁，建议你检出 tag 为 lane-detection-code-tour 的代码进行对照阅读。


### 选取 ROI

main() 函数位于 driveassist.cpp 文件中，该文件的开始部分定义了一些用于测试的视频的参数。由于该版本的代码仅做研究用，所以将测试视频文件的地址写死在了代码中。

roiX、roiY、roiWidth、roiHeight 就是 ROI 的参数，由于车道线仅仅会出现在视频画面中的固定区域，所以我们可以选取这块固定的区域作为 ROI，这样可以加快处理的速度，也可以避开环境的干扰。

ROI 参数根据不同的视频需要自行调节。


### 进行俯视变换

从视频画面中来看，车道线是倾斜而且不平行的，但如果我们从空中俯视车道线，应该能看到平行的车道线。平行的车道线比不平行的车道线更容易处理。另外，当我们把 ROI 变换成 IPM 后，在直行的道路上，车道线会变成垂直的线，这就能够让我们更容易地识别出车道线。

要严格地进行俯视变换，需要考虑到摄像头高度、倾角、仰角、光圈大小等不容易测量的量，但我们不需要进行精确的变换，我们只需要做一个简单的梯形变形，就能够得到一个俯视图。虽然这样做得到的俯视图并不精确，但对车道线识别来说已经够用了。

由于摄像头安装位置的不同，我们需要根据实际画面调整一些参数，以便进行俯视变换，我们将这个过程叫做标定。下面介绍标定的过程。

首先运行程序，选择一个车辆保持在车道线中央，且当前车道是直道的场景，接着开始进行标定。

请看下图，图片底部中央的绿色细线的矩形就是 ROI，举行中央的两条绿色细线是用于调整俯视变换参数的辅助线。

![01-标定 ROI 和俯视变换参数](http://youxia-cdn.b0.upaiyun.com/user/da/ec/2fbdc130b09772288745f78ff68f.png)

标定方法如下：

1. 调整“原图”窗口中的参数，让 ROI 的左下角和右下角正好压在实际的车道线上，ROI 的下边线应该尽可能接近画面的底部；
1. 调整“感兴趣区域”窗口中的 srcX 参数，让 ROI 中两条绿色细线和 ROI 上边线的交点正好压在实际的车道线上；
1. 在确保满足前两条的条件下，适当调整 ROI 上边线的位置，尽量让 ROI 有较高的高度，同时确保 ROI 中两条绿色辅助线不要相距太近。

标定完成之后，可以将这些参数记下来，或者直接改写代码中预设的参数，这样在下次运行程序时，就不需要重新进行标定了。

标定原理是这样的，画面中的车道线和 ROI 的上下两条边线组成了一个梯形，我们只要把这个梯形拉伸成一个矩形，就可以完成俯视变换。严格来说，这并不是一个标准的俯视变换，但我们只需要将车道线变换成平行的且垂直于地平线的两条线，这样的变换对我们来说已经足够了。

如下图所示，我们需要将 E、F 点分别拉伸到 A、B 两点，C 和 D 点保持不动，也就是说，我们的变换是这样的：

![02-俯视变换中的梯形变形](http://youxia-cdn.b0.upaiyun.com/user/c4/50/cc5865b692f64efcda2a2c2a0c7c.png)

* E --> A
* F --> B
* C --> C
* D --> D

将这四个点的坐标传给 OpenCV 提供的 getPerspectiveTransform 方法，我们就得到了我们想要的俯视变换的变换矩阵。同时，我们可以求这个矩阵的伪逆矩阵，这样我们就可以将俯视图转换为 ROI 图。


下面是一个 ROI 转换成俯视变换的对比图，可以看出车道线已经变成了两条平行线，并且在屏幕上是垂直的。

![03-ROI 和俯视变换的对比](http://youxia-cdn.b0.upaiyun.com/user/4e/7a/da2f9686aec9f6cc5bc2017f8700.png)


### 车道线增强

现在我们已经获得了姿态比较好的车道线（车道线平行，且几乎是垂直的），为了进一步突出车道线，我们要使用一个特殊的高斯核函对图像进行卷积。

这个高斯核的数学表达是这样的：

$$
f_{u}(x) = \frac{1}{\sigma^{2}_{x}} exp(-\frac{x^2}{2\sigma^{2}_{x}) (1 - \frac{x^2}{\sigma^{2}_{x}}
f_{v}(y) = exp(-\frac{1}{2\sigma^{2}_y}y^2)
$$

这个高斯核的水平和垂直方向看起来是这样的（$\sigma_{x}$ 和 $\sigma_{y}$ 均取 5）：

![04-水平方向的高斯核响应](http://youxia-cdn.b0.upaiyun.com/user/bc/8e/cf5efdf5f2239b4dab19bf7b0f46.png)
![05-垂直方向的高斯核响应](http://youxia-cdn.b0.upaiyun.com/user/5d/bc/429e97a3e10e2be8fa1f573c8ab6.png)

两个高斯核合并起来之后，看起来就是这个样子的：

![06-车道线增强使用的高斯核的响应](http://youxia-cdn.b0.upaiyun.com/user/cf/da/720f9f6373fbc298f456f570dcd6.png)

可以看到，这个高斯核在水平方向增强了中央的响应，弱化了周围的相应，同时，在垂直方向拉伸了响应。用这个高斯核对图像进行卷积后，就可以增强车道线的响应。

$\sigma^{2}_{x}$ 一般取车道线宽度在图像上占据的像素个数，而 $\sigma^{2}_{y}$ 一般取虚线车道线的长度在图像上占据的像素个数。

在代码中，高斯核的计算在 onGaussianChange 函数中完成。首先分别计算水平方向和垂直方向的卷积核，然后调用 OpenCV 提供的 sepFilter2D 方法，分别传入水平和垂直方向的卷积核，就可以得到最终的卷积结果。

完成卷积操作后，车道线会在图片上显现出最强的响应，这时候我们要做一个阈值化操作，将车道线过滤出来，把无关的背景（如路面纹理等）消除。

阈值化的操作很简单，计算图像中所有像素值的分布，确定一个阈值，然后保留所有像素值大于阈值的点，删除所有像素值小于阈值的点。在本代码中，我们使用了 97.5% 作为阈值，也就是取像素值分布中位于 97.5% 这个位置的像素值作为阈值。实际的阈值在每一帧中都不相同，而 97.5% 是固定的，需要根据每一帧的像素值分布来确定实际使用的阈值。

车道线经过增强后的效果如下：

![07-车道线增强前后的对比](http://youxia-cdn.b0.upaiyun.com/user/3a/e9/5f6a43fb3063e82b2dafc2d58471.png)


